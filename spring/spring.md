BeanFactory 
访问Spring Bean容器的根接口，此接口定义了一些访问Bean的基本方法，一个BeanFactory会加载BeanDefinition，根据BeanDefinition返回其实例化对象


ListableBeanFactory
增加可以返回当前BeanFactory所持有注册进来的BeanDefinition列表，除了两个获取Bean的名称和实例映射的方法可以返回注册进来的单例Bean，其他几个方法只能返回通过BeanDefinition定义的Bean信息

hierarchicalBeanFactory
提供BeanFactory的继承关系，有了parentBeanFactory的层级

AutowireCapableBeanFactory
提供自动注入的能力，这个BeanFactory提供的都是一些写的方法，比如createBean，autowireBean，配置Bean的属性，注入依赖，解析依赖等

ConfigurableBeanFactory
除继承了HierarchicalBeanFactory 和 SingletonBeanRegistry外，增加了很多set/get方法，主要用于向BeanFactory增加一些配置内容。
比如属性编辑器，内嵌值解析器，新增BeanPostProcessor，类型转换服务等



ConfigurableListableBeanFactory
增加了几个方法，更像是了继承了ListableBeanFactory AutowireCapableBeanFactory ConfigurableBeanFactory之后，
为了更好的整合，补充的。可以分析和修改bean definition，以及预实例化单例bean



SingletonBeanRegistry
定义一个共享Bean实例的注册器，可以被BeanFactory继承，来实现统一的单例管理行为
这个接口中实现的注册进来的单例Bean，都是在外部已经创建并初始化好的对象实例，在通过这个接口注册时，不会回调任何初始化方法，也不会有销毁方法的回调。
接口的直接实现是DefaultSingletonBeanRegistry，注册进来的单例Bean，在这里被单独管理。

DefaultSingletonBeanRegistry
共享Bean实例的通用注册器，允许注册一个被所有此注册器调用者共享的实例对象，通过BeanName获取。
这个类作为一个BeanFactory的基础服务类，即没有BeanDefinition的概念，也没有Bean的创建过程。

beforeSingletonCreation afterSingletonCreation，会分别在Bean的创建前后被调用，如果Bean需要做创建中校验的话，会记录下当前Bean创建中，或者不在创建中

几个getSingleton方法的实现逻辑

getSingleton(String,boolean)
在无锁的情况下依次从Map singletonObjects和earlySingletonObjects中根据beanName搜索，如果没有获取到，根据第二个参数是否允许从早期引用中获取。
如果为true的话，在加锁的情况下，再检查一遍是否对应的Bean实例已经创建，如果还是没有创建，则从singletonFactories中查找是否存在ObjectFactory,
如果能找到，就会创建一个Bean实例，并且记录到earlySingletonObjects，移除已经执行过的ObjectFactory

getSingleton(String,ObjectFactory<?>)
对singletonObjects加锁，然后查找是否有对应的实例存在，如果不存在且没有在销毁阶段，记录下正在创建的Bean，开始回调ObjectFactory#getObject方法，
在finally中从正在创建的Bean Map中移除此BeanName，并且调用addSingleton方法，写入到singletonObjects

addSingletonFactory(String, ObjectFactory<?>)
添加一个ObjectFactory，添加之前会校验同名的name是否已经存在了Bean的单实例，不存在的情况下，才会新增成功

如何解决循环依赖

如果循环依赖出现在构造器注入的情况下，无论如何都解决不了的。循环依赖有个配置项来配置是否开启

Bean的创建开始于getBean方法的调用，在doGetBean方法中，会调用getSingleton(String,ObjectFactory<?>)，这个方法中会回调createBean，
createBean方法中，创建对象实例，然后判断当前Bean是否创建中、是否允许循环依赖、是否单例Bean，如果都满足，就表示提前暴露Bean的实例对象，也
就是会调用addSingletonFactory(String, ObjectFactory<?>)方法，以后就会执行自动注入populateBean，在处理依赖的Bean时，假如遇到了
被依赖的Bean又依赖了这个Bean，也就是循环依赖了，就会试图get这个Bean，然后调用getSingleton(String)方法，之后就会从singletonObjects找到
上面添加的ObjectFactory，从而拿到之前的Bean实例对象，解决了循环依赖的问题。

这其中注意到add进来的ObjectFactory里调用的是getEarlyBeanReference方法，这个方法是可以返回代理对象实例的。这种是作为依赖时且是需要代理的Bean

如果是一个代理Bean，直接getBean，在什么时候被代理的？


Bean的创建过程是包含在获取Bean的过程中的
1、调用getBean
2、调用getSingleton，尝试从缓存中查找手动注册的Bean，这个期间会按照顺序查询DefaultSingletonBeanRegistry#singletonObject，如果要查找的Bean
正在创建中（出现循环引用时），尝试从earlySingletonObjects中查找。还没有的话，尝试从singletonFactories获取ObjectFactory，如果存在，获取到Bean
实例，然后写入earlySingletonObjects，移除ObjectFactory
3、上一步能找到则返回，找不到开始创建
4、将创建过程，包装成ObjectFactory，在getSingleton方法中进行回调。在实际的回调前后，会把这个Bean加入到正在创建的Bean集合中
5、createBean的过成中，先使用反射创建实例对象，之后根据是否单例对象、Bean是否创建中、是否允许引用，来判断是否应该在Bean还没有
创建好的情况，将Bean实例暴露出去，所谓的暴露就是调用addSingletonFactory方法，包含了已创建的Bean原始实例对象，也就是在singletonFactories这个Map
增加一个ObjectFactory，这个ObjectFactory持有刚刚创建的实例对象
6、对Bean的属性做填充（属性填充的过程过中，会涉及到依赖Bean的创建，回到1的过程）
7、调用Bean的初始化方法，在初始化前后，会调用postProcessBeforeBeanInitialization和postProcessAfterBeanInitialization，后者可以返回一个代理对象，
也是Spring AOP中创建代理对象的位置。
8、方法栈再次回到getSingleton方法，将当前Bean从正在创建Bean集合中移除，然后从earlySingletonObjects移除，向singletonObjects新增一个单例对象。
9、一个Bean的创建结束



